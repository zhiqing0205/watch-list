#!/usr/bin/env node

/**
 * ÂÆöÊó∂Êï∞ÊçÆÂ∫ìÂ§á‰ªΩËÑöÊú¨ - ÊîØÊåÅOSS‰∏ä‰º†
 * ÊØèÂ§©ÂáåÊô®3ÁÇπÊâßË°åÔºåÂ§á‰ªΩÊï∞ÊçÆÂπ∂‰∏ä‰º†Âà∞ÈòøÈáå‰∫ëOSS
 */

const { PrismaClient } = require('@prisma/client');
const OSS = require('ali-oss');
const path = require('path');
const fs = require('fs');

const prisma = new PrismaClient();

// OSSÈÖçÁΩÆ
const ossClient = new OSS({
  region: process.env.OSS_REGION || 'oss-cn-hongkong',
  accessKeyId: process.env.OSS_ACCESS_KEY_ID,
  accessKeySecret: process.env.OSS_ACCESS_KEY_SECRET,
  bucket: process.env.OSS_BUCKET_NAME || 'watch-list'
});

// ÂàõÂª∫Â§á‰ªΩÁõÆÂΩï
const backupDir = path.join(__dirname, '..', 'backups');
if (!fs.existsSync(backupDir)) {
  fs.mkdirSync(backupDir, { recursive: true });
}

async function scheduledBackup() {
  const startTime = new Date();
  console.log(`üïí [${startTime.toISOString()}] ÂºÄÂßãÂÆöÊó∂Â§á‰ªΩ‰ªªÂä°...`);
  
  try {
    // ÁîüÊàêÊó•ÊúüÊ†áËØÜ
    const dateStr = startTime.toISOString().split('T')[0]; // YYYY-MM-DD
    const timestamp = startTime.toISOString()
      .replace(/:/g, '-')
      .replace(/\..+/, '')
      .replace('T', '_');

    // 1. Ëé∑ÂèñÊâÄÊúâÊï∞ÊçÆ
    console.log('üìä Ê≠£Âú®Êî∂ÈõÜÊï∞ÊçÆ...');
    const [users, movies, tvShows, actors, movieCast, tvCast, movieReviews, tvReviews, operationLogs] = await Promise.all([
      prisma.user.findMany(),
      prisma.movie.findMany(),
      prisma.tvShow.findMany(),
      prisma.actor.findMany(),
      prisma.movieCast.findMany(),
      prisma.tvCast.findMany(),
      prisma.movieReview.findMany(),
      prisma.tvReview.findMany(),
      prisma.operationLog.findMany()
    ]);

    const backupFile = path.join(backupDir, `backup_${timestamp}.sql`);
    const jsonBackupFile = path.join(backupDir, `backup_${timestamp}.json`);

    // 2. ÁîüÊàêSQLÂ§á‰ªΩ
    console.log('üíæ ÁîüÊàêSQLÂ§á‰ªΩ...');
    let sqlContent = `-- Scheduled Database Backup
-- Created: ${startTime.toISOString()}
-- Date: ${dateStr}

SET session_replication_role = replica;

-- Clear existing data
TRUNCATE TABLE "operation_logs", "tv_reviews", "movie_reviews", "tv_cast", "movie_cast", "actors", "tv_shows", "movies", "users" RESTART IDENTITY CASCADE;

`;

    // ËΩ¨‰πâÂíåÊ†ºÂºèÂåñÂáΩÊï∞
    const escapeSQLString = (str) => {
      if (str === null || str === undefined) return 'NULL';
      return `'${str.toString().replace(/'/g, "''")}'`;
    };

    const formatDate = (date) => {
      if (!date) return 'NULL';
      return `'${new Date(date).toISOString()}'`;
    };

    const formatArray = (arr) => {
      if (!arr || arr.length === 0) return "'{}'";
      return `'{${arr.map(item => `"${item.replace(/"/g, '\\"')}"`).join(',')}}'`;
    };

    const formatJSON = (obj) => {
      if (!obj) return 'NULL';
      return `'${JSON.stringify(obj).replace(/'/g, "''")}'`;
    };

    // ÊèíÂÖ•Users
    if (users.length > 0) {
      sqlContent += '-- Insert Users\n';
      users.forEach(user => {
        sqlContent += `INSERT INTO "users" ("id", "username", "email", "name", "password", "role", "isActive", "lastLoginAt", "createdAt", "updatedAt") VALUES (${user.id}, ${escapeSQLString(user.username)}, ${escapeSQLString(user.email)}, ${escapeSQLString(user.name)}, ${escapeSQLString(user.password)}, ${escapeSQLString(user.role)}, ${user.isActive}, ${formatDate(user.lastLoginAt)}, ${formatDate(user.createdAt)}, ${formatDate(user.updatedAt)});\n`;
      });
      sqlContent += '\n';
    }

    // ÊèíÂÖ•Movies
    if (movies.length > 0) {
      sqlContent += '-- Insert Movies\n';
      movies.forEach(movie => {
        sqlContent += `INSERT INTO "movies" ("id", "tmdbId", "title", "originalTitle", "overview", "releaseDate", "runtime", "genres", "posterPath", "backdropPath", "posterUrl", "backdropUrl", "imdbId", "doubanRating", "tmdbRating", "watchStatus", "summary", "playUrl", "isVisible", "createdAt", "updatedAt") VALUES (${movie.id}, ${movie.tmdbId}, ${escapeSQLString(movie.title)}, ${escapeSQLString(movie.originalTitle)}, ${escapeSQLString(movie.overview)}, ${formatDate(movie.releaseDate)}, ${movie.runtime || 'NULL'}, ${formatArray(movie.genres)}, ${escapeSQLString(movie.posterPath)}, ${escapeSQLString(movie.backdropPath)}, ${escapeSQLString(movie.posterUrl)}, ${escapeSQLString(movie.backdropUrl)}, ${escapeSQLString(movie.imdbId)}, ${movie.doubanRating || 'NULL'}, ${movie.tmdbRating || 'NULL'}, ${escapeSQLString(movie.watchStatus)}, ${escapeSQLString(movie.summary)}, ${escapeSQLString(movie.playUrl)}, ${movie.isVisible}, ${formatDate(movie.createdAt)}, ${formatDate(movie.updatedAt)});\n`;
      });
      sqlContent += '\n';
    }

    // ÊèíÂÖ•TV Shows
    if (tvShows.length > 0) {
      sqlContent += '-- Insert TV Shows\n';
      tvShows.forEach(tv => {
        sqlContent += `INSERT INTO "tv_shows" ("id", "tmdbId", "name", "originalName", "overview", "firstAirDate", "lastAirDate", "numberOfSeasons", "numberOfEpisodes", "genres", "posterPath", "backdropPath", "posterUrl", "backdropUrl", "imdbId", "doubanRating", "tmdbRating", "watchStatus", "summary", "playUrl", "isVisible", "createdAt", "updatedAt") VALUES (${tv.id}, ${tv.tmdbId}, ${escapeSQLString(tv.name)}, ${escapeSQLString(tv.originalName)}, ${escapeSQLString(tv.overview)}, ${formatDate(tv.firstAirDate)}, ${formatDate(tv.lastAirDate)}, ${tv.numberOfSeasons || 'NULL'}, ${tv.numberOfEpisodes || 'NULL'}, ${formatArray(tv.genres)}, ${escapeSQLString(tv.posterPath)}, ${escapeSQLString(tv.backdropPath)}, ${escapeSQLString(tv.posterUrl)}, ${escapeSQLString(tv.backdropUrl)}, ${escapeSQLString(tv.imdbId)}, ${tv.doubanRating || 'NULL'}, ${tv.tmdbRating || 'NULL'}, ${escapeSQLString(tv.watchStatus)}, ${escapeSQLString(tv.summary)}, ${escapeSQLString(tv.playUrl)}, ${tv.isVisible}, ${formatDate(tv.createdAt)}, ${formatDate(tv.updatedAt)});\n`;
      });
      sqlContent += '\n';
    }

    // ÊèíÂÖ•Actors
    if (actors.length > 0) {
      sqlContent += '-- Insert Actors\n';
      actors.forEach(actor => {
        sqlContent += `INSERT INTO "actors" ("id", "tmdbId", "name", "originalName", "biography", "birthday", "deathday", "gender", "profilePath", "profileUrl", "createdAt", "updatedAt") VALUES (${actor.id}, ${actor.tmdbId}, ${escapeSQLString(actor.name)}, ${escapeSQLString(actor.originalName)}, ${escapeSQLString(actor.biography)}, ${formatDate(actor.birthday)}, ${formatDate(actor.deathday)}, ${actor.gender || 'NULL'}, ${escapeSQLString(actor.profilePath)}, ${escapeSQLString(actor.profileUrl)}, ${formatDate(actor.createdAt)}, ${formatDate(actor.updatedAt)});\n`;
      });
      sqlContent += '\n';
    }

    // ÊèíÂÖ•Movie Cast
    if (movieCast.length > 0) {
      sqlContent += '-- Insert Movie Cast\n';
      movieCast.forEach(cast => {
        sqlContent += `INSERT INTO "movie_cast" ("id", "movieId", "actorId", "character", "order") VALUES (${cast.id}, ${cast.movieId}, ${cast.actorId}, ${escapeSQLString(cast.character)}, ${cast.order || 'NULL'});\n`;
      });
      sqlContent += '\n';
    }

    // ÊèíÂÖ•TV Cast
    if (tvCast.length > 0) {
      sqlContent += '-- Insert TV Cast\n';
      tvCast.forEach(cast => {
        sqlContent += `INSERT INTO "tv_cast" ("id", "tvShowId", "actorId", "character", "order") VALUES (${cast.id}, ${cast.tvShowId}, ${cast.actorId}, ${escapeSQLString(cast.character)}, ${cast.order || 'NULL'});\n`;
      });
      sqlContent += '\n';
    }

    // ÊèíÂÖ•Movie Reviews
    if (movieReviews.length > 0) {
      sqlContent += '-- Insert Movie Reviews\n';
      movieReviews.forEach(review => {
        sqlContent += `INSERT INTO "movie_reviews" ("id", "movieId", "userId", "rating", "review", "createdAt", "updatedAt") VALUES (${review.id}, ${review.movieId}, ${review.userId}, ${review.rating || 'NULL'}, ${escapeSQLString(review.review)}, ${formatDate(review.createdAt)}, ${formatDate(review.updatedAt)});\n`;
      });
      sqlContent += '\n';
    }

    // ÊèíÂÖ•TV Reviews
    if (tvReviews.length > 0) {
      sqlContent += '-- Insert TV Reviews\n';
      tvReviews.forEach(review => {
        sqlContent += `INSERT INTO "tv_reviews" ("id", "tvShowId", "userId", "rating", "review", "createdAt", "updatedAt") VALUES (${review.id}, ${review.tvShowId}, ${review.userId}, ${review.rating || 'NULL'}, ${escapeSQLString(review.review)}, ${formatDate(review.createdAt)}, ${formatDate(review.updatedAt)});\n`;
      });
      sqlContent += '\n';
    }

    // ÊèíÂÖ•Operation Logs (Êñ∞Â≠óÊÆµÁªìÊûÑ)
    if (operationLogs.length > 0) {
      sqlContent += '-- Insert Operation Logs\n';
      operationLogs.forEach(log => {
        sqlContent += `INSERT INTO "operation_logs" ("id", "userId", "operatorName", "action", "entityType", "resourceId", "resourceName", "resourceType", "description", "metadata", "createdAt") VALUES (${log.id}, ${log.userId}, ${escapeSQLString(log.operatorName)}, ${escapeSQLString(log.action)}, ${escapeSQLString(log.entityType)}, ${log.resourceId || 'NULL'}, ${escapeSQLString(log.resourceName)}, ${escapeSQLString(log.resourceType)}, ${escapeSQLString(log.description)}, ${formatJSON(log.metadata)}, ${formatDate(log.createdAt)});\n`;
      });
      sqlContent += '\n';
    }

    // Êõ¥Êñ∞Â∫èÂàó
    sqlContent += `-- Update sequences
SELECT setval('"users_id_seq"', (SELECT COALESCE(MAX("id"), 1) FROM "users"));
SELECT setval('"movies_id_seq"', (SELECT COALESCE(MAX("id"), 1) FROM "movies"));
SELECT setval('"tv_shows_id_seq"', (SELECT COALESCE(MAX("id"), 1) FROM "tv_shows"));
SELECT setval('"actors_id_seq"', (SELECT COALESCE(MAX("id"), 1) FROM "actors"));
SELECT setval('"movie_cast_id_seq"', (SELECT COALESCE(MAX("id"), 1) FROM "movie_cast"));
SELECT setval('"tv_cast_id_seq"', (SELECT COALESCE(MAX("id"), 1) FROM "tv_cast"));
SELECT setval('"movie_reviews_id_seq"', (SELECT COALESCE(MAX("id"), 1) FROM "movie_reviews"));
SELECT setval('"tv_reviews_id_seq"', (SELECT COALESCE(MAX("id"), 1) FROM "tv_reviews"));
SELECT setval('"operation_logs_id_seq"', (SELECT COALESCE(MAX("id"), 1) FROM "operation_logs"));

SET session_replication_role = DEFAULT;
`;

    // 3. ÂÜôÂÖ•Êú¨Âú∞Êñá‰ª∂
    fs.writeFileSync(backupFile, sqlContent);

    // 4. ÂàõÂª∫JSONÂ§á‰ªΩ
    const jsonData = {
      backupDate: startTime.toISOString(),
      version: '2.0',
      schema: 'refactored',
      stats: {
        users: users.length,
        movies: movies.length,
        tvShows: tvShows.length,
        actors: actors.length,
        movieCast: movieCast.length,
        tvCast: tvCast.length,
        movieReviews: movieReviews.length,
        tvReviews: tvReviews.length,
        operationLogs: operationLogs.length
      },
      data: {
        users, movies, tvShows, actors, movieCast, tvCast, movieReviews, tvReviews, operationLogs
      }
    };
    fs.writeFileSync(jsonBackupFile, JSON.stringify(jsonData, null, 2));

    // 5. ‰∏ä‰º†Âà∞OSS
    console.log('‚òÅÔ∏è  ‰∏ä‰º†Â§á‰ªΩÂà∞OSS...');
    
    const ossDir = `backup/${dateStr}`;
    const sqlFileName = `backup_${timestamp}.sql`;
    const jsonFileName = `backup_${timestamp}.json`;

    try {
      // ‰∏ä‰º†SQLÊñá‰ª∂
      const sqlUploadResult = await ossClient.put(`${ossDir}/${sqlFileName}`, backupFile);
      console.log(`‚úÖ SQLÂ§á‰ªΩ‰∏ä‰º†ÊàêÂäü: ${sqlUploadResult.url}`);

      // ‰∏ä‰º†JSONÊñá‰ª∂
      const jsonUploadResult = await ossClient.put(`${ossDir}/${jsonFileName}`, jsonBackupFile);
      console.log(`‚úÖ JSONÂ§á‰ªΩ‰∏ä‰º†ÊàêÂäü: ${jsonUploadResult.url}`);

      // 6. ËÆ∞ÂΩïÂ§á‰ªΩÊìç‰ΩúÂà∞Êìç‰ΩúÊó•Âøó
      await prisma.operationLog.create({
        data: {
          userId: 1, // Á≥ªÁªüÁî®Êà∑
          operatorName: 'SYSTEM',
          action: 'SCHEDULED_BACKUP',
          entityType: 'SYSTEM',
          resourceType: 'DATABASE',
          description: `ÂÆöÊó∂Â§á‰ªΩÂÆåÊàêÔºåÂåÖÂê´ ${jsonData.stats.movies} ÈÉ®ÁîµÂΩ±Ôºå${jsonData.stats.tvShows} ÈÉ®ÁîµËßÜÂâßÔºå${jsonData.stats.actors} ‰ΩçÊºîÂëò`,
          metadata: {
            backupDate: dateStr,
            sqlFile: `${ossDir}/${sqlFileName}`,
            jsonFile: `${ossDir}/${jsonFileName}`,
            stats: jsonData.stats,
            duration: new Date() - startTime
          }
        }
      });

      // 7. Ê∏ÖÁêÜÊú¨Âú∞Êñá‰ª∂ÔºàÂèØÈÄâÔºå‰øùÁïôÊúÄËøë3Â§©ÁöÑÂ§á‰ªΩÔºâ
      const localFiles = fs.readdirSync(backupDir);
      const backupFiles = localFiles.filter(file => 
        file.startsWith('backup_') && (file.endsWith('.sql') || file.endsWith('.json'))
      );

      if (backupFiles.length > 6) { // ‰øùÁïôÊúÄËøë3Â§©ÁöÑÂ§á‰ªΩÔºàSQL + JSONÔºâ
        const sortedFiles = backupFiles
          .map(file => ({
            name: file,
            path: path.join(backupDir, file),
            mtime: fs.statSync(path.join(backupDir, file)).mtime
          }))
          .sort((a, b) => b.mtime - a.mtime);

        const filesToDelete = sortedFiles.slice(6);
        filesToDelete.forEach(file => {
          fs.unlinkSync(file.path);
          console.log(`üóëÔ∏è  Â∑≤Âà†Èô§ÊóßÂ§á‰ªΩ: ${file.name}`);
        });
      }

      const endTime = new Date();
      const duration = Math.round((endTime - startTime) / 1000);

      console.log(`üéâ ÂÆöÊó∂Â§á‰ªΩ‰ªªÂä°ÂÆåÊàê!`);
      console.log(`üìä Â§á‰ªΩÁªüËÆ°:`);
      console.log(`  Áî®Êà∑: ${users.length} Êù°`);
      console.log(`  ÁîµÂΩ±: ${movies.length} Êù°`);
      console.log(`  ÁîµËßÜÂâß: ${tvShows.length} Êù°`);
      console.log(`  ÊºîÂëò: ${actors.length} Êù°`);
      console.log(`  Êìç‰ΩúÊó•Âøó: ${operationLogs.length} Êù°`);
      console.log(`‚è±Ô∏è  ÊÄªËÄóÊó∂: ${duration} Áßí`);

    } catch (ossError) {
      console.error('‚ùå OSS‰∏ä‰º†Â§±Ë¥•:', ossError.message);
      throw ossError;
    }

  } catch (error) {
    console.error('‚ùå Â§á‰ªΩ‰ªªÂä°Â§±Ë¥•:', error);
    
    // ËÆ∞ÂΩïÈîôËØØÂà∞Êìç‰ΩúÊó•Âøó
    try {
      await prisma.operationLog.create({
        data: {
          userId: 1,
          operatorName: 'SYSTEM',
          action: 'BACKUP_FAILED',
          entityType: 'SYSTEM',
          resourceType: 'DATABASE',
          description: `ÂÆöÊó∂Â§á‰ªΩÂ§±Ë¥•: ${error.message}`,
          metadata: {
            error: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
          }
        }
      });
    } catch (logError) {
      console.error('‚ùå ËÆ∞ÂΩïÈîôËØØÊó•ÂøóÂ§±Ë¥•:', logError);
    }
    
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// Ê£ÄÊü•ÊòØÂê¶Áõ¥Êé•ÊâßË°å
if (require.main === module) {
  scheduledBackup().catch(error => {
    console.error('‚ùå ËÑöÊú¨ÊâßË°åÂ§±Ë¥•:', error);
    process.exit(1);
  });
}

module.exports = { scheduledBackup };